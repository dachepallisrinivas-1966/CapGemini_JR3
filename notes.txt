Srinivas Dachepalli | 6305 730 633 | dachepallisrinivas@gmail.com

Abhishek Kumar - 9384526411
Aksheya -        9840129171

----------------------------------------------------------------------------

What is Java?
    is a high level strictly but partially object oriented progrmming.

    + Strictly object oriented, as there is no way possible to implement any java application 
      without using OOP.,
    + Partially object oriented, as java supports native variables and native types which are
      not objects and classes

Who developed Java?
    Sun microsystems - James Gosling
    Oracle corp. is the present owner of Java language.
    (www.oracle.com)

Histroy And Evolution
----------------------------------------
    JDK Alpha and Beta (1995)
    JDK 1.0 (23rd Jan 1996)
    JDK 1.1 (19th Feb 1997)
    J2SE 1.2 (8th Dec 1998)                             Stable  
    J2SE 1.3 (8th May 2000)
    J2SE 1.4 (6th Feb 2002)                             Stable and Prominent
    J2SE 5.0 (30th Sep 2004)                            Stable, Prominent and Revolutionary
    Java SE 6 (11th Dec 2006)
    Java SE 7 (28th July 2011)
    Java SE 8 (18th Mar 2014)   (LTS)                   Stable and Most used on current day 
    Java SE 9 (21st Sep 2017)
    Java SE 10 (20th Mar 2018)
    Java SE 11 (Sep 2018)       (LTS)                   Stable and being adopted 
    Java SE 12 (Mar 2019)
    Java SE 13 (Sep 2019)
    Java SE 14 (Mar 2020)
    Java SE 15 (Sep 2020)

Java Distributions
-------------------------------------
        JRE                 Java Runtime Environment         
                                {Java Libraries,GC,JVM,Interpreter,ClassLoader,ByteCodeVerifeir,...}
        
        JDK                 Java (Standard) Development Kit    
                                {JRE, Development Tools, IDE Support}

Java Editions
-------------------------------------

        Java Standard Edition 
        ==================================
                Core Language                
                Java Core Libraries
                -------------------------
                    java.lang               Math, String, System, Exceptions, Multi-Threading
                    (it is imported automatically)
                    java.time               Date and Time API
                    java.util               Generics and Collections
                    java.util.stream        Streams API and Lambda Expressions
                    java.util.regex         Regular Expressions
                    java.io                 IO Streams
                    java.nio                New IO Streams
                    java.sql                JDBC

        Java Enterprise Edition
        ==================================
            App                 Specifications            Implementations         Frameworks
            ----                -----------------------  ----------------        -------------
            Dynamic Web Apps    Servlets and JSP         WebServers like Tomcat     Struts
                                                                                    Spring

            ORM                 JPA, JTA                 Hibernate,TopLink,
                                                         EclipseLink...
                    
            WebServices         JAX-WS, JAX-RS           Axis2,Apache CXF
                                          
            Microservices ...and more

        Java Micro Edition
        ==================================

                supports smart device / smart card based application development.

C/C++ program execution process:
---------------------------------
text editor     -   source program  -                   sample.c / sample.cpp
compiler        -   object program  -                   sample.obj / sample.o
                    (intermeditate program)
linker          -   header files (.h)   -               sample.exe 
                    all the header files are linked 
                    to the object program and create
                    an executable program.
loader          -   to supply the executable code to
                    the  O/S for execution.

C/C++ languages are platform dependent languages. (here platform means o/s)

Java program excution process:
------------------------------
text editor             -   source code     -   sample.java
compiler   (javac)      -   byte code       -   sample.class   
                    (byte code is not in the form of 0's & 1's)

is this sample.class is targeted to one particular O/S ?
NO.

sample.class is not an executable program.

byte code   --> JVM (Java Virtual Machine) -> JVM will convert the byte code 
        into native machine code (sequence of 0's & 1's understood by that particular
        O/S in which the program is executed)
        the program is executed.

        machine code is generated ON-THE-FLY.

Java is platform (means o/s) independent language.

is JDK  common for all O/S? -   (platform dependent)
    NO
is JRE  common for all O/S? -   (platform dependent)
    No
is JVM  common for all O/S? -   (platform dependent)
    NO

BYTE CODE is the only one component which is platform independent.

is Native machine code common for all O/S?
    NO

JDK   (Java Development Kit)  
    for developers.
    lot of tools to develop java applications.
    
    javac   -   java compiler
    java    -   interpreter
    javadoc -   to create HTML documentation of a project
    javap
    jdb     -   java debugger
    appletviewer

JRE   (Java Runtime Environment)
    JRE provide JVM + other libraries

Features of Java:
-----------------
1. platform independent
2. object oriented 
3. secured
        no explicit pointers in java.
        java programs run inside a special environment i.e. JVM.
        JVM will talk to O/S.
        (JVM is a collection of programs - class-loader, byte-code-verifier, garbage-collector)
4. robust
        means fault-tolerant, strong, vigour and healthy.
        a. exception handling
        b. automatic garbage collection
        c. strong type checking.
5. self-documented (open source)
    source code is visible to anyone.
6. architectural neutral
7. compiled and interpreted



CODING STANDARDS / BEST PRACTICES
1. maintain proper indentation.
2. naming conventions



                            Java Tokens
                            -----------
smallest element in the program.

1. identifier
        it is a name given to variables, class, method names, package etc.,

        variable, method names must follow camel notation 
            first word is in lowercase.
            from the second word onwards use first letter of each word is in uppercase
            and rest in lower case.

            eg:
                length
                lengthOfRectangle
                circleArea

                acceptData()
                showMinMaxInArray()
        
        class names, file name and project must follow pascal notation.
        (first letter of each word in uppercase and the rest in lowercase).
            eg:
                ArrayIndexOutOfBoundsException
                RuntimeException
                String

        package name
            always in lowercase
            there are often abbreviated.
            eg:
                io
                lang
                awt
                util
                
        constants
            always be in uppercase.
            it is a name given to literal.
            it is immutable.
            it is qualified with "final" keyword.
            they can be separated with an underscore.

            final double PIE = 3.14;
                    PIE is a constant.
                    3.14 is literal

            final int PASS_MARKS = 35;
            final int MAX_MARKS = 100;
            final int BATCH_CAPACITY = 40;
            
            double circumference = 2 * PIE * radius;

            keyword         double
            indentifier     circumference
            operator        =
            literal         2
            operator        *
            constant        PIE
            operator        *
            identifier      radius
            operator        ;


2. keywords
        these are also reserved words.
        eg: if, switch, for, while
            int, float, double

3. operators
        unary operators
           which takes only one operand.
           ++   --  !    
        binary operators
            it takes two operands
            all the remaining 
        ternary operator
            which takes three operands.
            conditional operator


        a) arithmetic operators :   +   -   *   /   %
        b) relational operator  :   >   <   ==  >=  <=  !=
        c) logical operators    :   &&  ||  !
        d) conditional operator :   (condition) ? true-statment : false-statement;
        e) assignment operator  :   =   +=  -=  *=  /=  %=
        f) increment / decrement :  ++, --
        g) bitwise operators    :   refer your self.
        h) misc. operators      :
                []
                ()
                <>
                ,
                .
                ;
                instanceof
4. literals
        any hard coded value.

        doule area = 3.14*radius*radius;

        3.14 is literal.

        a) integer literals
                i) decimal literal      (0-9)
                    30, -5

                ii) binary literal      (0,1)
                    0b101011
                    int a = 0b101;

                    observe the 0b prefix here.

                iii) octal literal      (0-7)
                    int a = 0234;

                    observe 0 prefix.

                iv) hexadecimal literal (0-9, A-F)
                    int a = 0xABC;

                    observe 0x prefix
                
        b) floating point literals
                3.14
        c) character literals
                character is a single alphabet, single digit or single special symbol.
                it the charcater is enclosed within single quotes, it is character constantt.

                'A'
                '7'
                '?'
                'AB'        invalid

                escape sequence characters:
                '\n'        new line character
                '\t'        tab


        d) string literals
                group of characters enclosed within double quotes.

                "srinivas"
                "49-53-20/25"
                "9247175823"
                "a"             
                ""              empty string

        e) boolean literals
                true, false

5. comments
        ignored by the compiler.

        end-of-line comment             //
        block comment                   /*  and */
        documentation comment           /** and */

Eclipse IDE:
------------
    1. change the perspective to "Java Perspective"
        (window -> perspective -> open perspective)
    2. change the Installed JRE : JDK1.8
        (windows -> preferences -> java -> installed jre)

    3. Create a java project : ToStartWith
        choose "default JRE as jdk1.8 ..." radio button

    Workspace, project are nothing folders in the o/s.


Package
------------
	It is a collection of classes, interfaces and sub-packages.
	If a class is not part of any package, it is automatically placed in "default package".
	purpose of a package is to solve name conflicts. 	
    if two or more classes share the same name, they cannot be part of the same package 
    as it leads to ambiguity.
    package is represented as a folder in O/S.

	if the class inside a package is public, we can make use of the class outside the package.

	whenever we have a public class, then the class name and file name must be the same.

	A single file can have only one public class. It can have any no. of non-public classes inside a single file.
	
	Name of the package is the reverse order of the web domain of the company.
    (www.capgemini.com)

    com.cg.tsw.ui, com.cg.tsw.model, com.cg.tsw.view, com.cg.tsw.controller


                                data types   
                                ----------
    primitve types
        numeric 
            integral
                byte        1
                short       2
                int         4
                long        8
            floating-point
                float       4
                double      8
        non-numeric
                char        2
                boolean     1 bit   -   true, false
                
                in java, true means not 1 and
                false means not 0.
                true, false are literals.

                void    
                generally used to specify the return type of a function.
    
    user-defined types
        class
        interface
        enum

                                            Control Structures
                                            ==================
if, if..else, switch, break, continue, 
while, do..while, for

we can use control structures to alter the program execution sequence.

if:
----
    it is a bi-directional decision making statement.

if (condition)
    st-1;           /* true statement */
[else
    st-2;]           /* false statement */

if (condition) {
    st-1;
    st-2;           /* true block */
    ...
} [ else {
    st-1;
    st-2;           /* false block */
    ...
} ]

what is a condition?
    condition means comparision.

what is the result of a condition?
    true / false

int a = 10, b = 15;
if (a > b);
    System.out.println(a);
System.out.println(b);

if (a > b)
    ;

System.out.println(a);
System.out.println(b);

just semi-colon indicates null statement.

output:
-------
10
15


int m = 10, n = 15;
if (m > n);
    System.out.println(m);
else
    System.out.println(n);

if (m > n)
    ;
System.out.println(m);

else
    System.out.println(n);

output:
-------
error : else without if.

types:
------
    simple if       (if without else)
    if .. else
    nested if       (if within if)
    ladder if       (if..else ladder)

+   string concatenation (joining) operator

1) write a java program to print whether a given year is leap or not.

nested if:
-----------
if (condition) {
    if (condition) {
        st-1;
        st-2;
        ...
    } else {
        st-1;
        st-2;
        ....
    }
}  else {
    if (condition) {
        st-1;
        st-2;
        ....
    } else {
        st-1;
        st-2;
        ...
    }
}

ladder if:
----------
if (condition) {
    st-1;
    st-2;
    ... 
} else if (condition) {
    st-1;
    st-2;
    ...
} else if (condition) {
    st-1;
    st-2;
    ...
} else {
    st-1;
    st-2;
    ...
}


2) switch:

    it is a multi-directional making statement.

syntax:
-------
    switch (var/expr) {
        case label-1 :  st-1;
                        st-2;
                        ...
                        [break;]
        case label-2 :  st-1;
                        st-2;
                        ...
                        [break;]
        ..  ..  ..  ..  ..  ..
        default:        st-1;
                        st-2;
                        ....
                        [break;]
    }


How do you accept data from the user?
--------------------------------------
    Scanner scan = new Scanner(System.in);

    nextInt()
    nextDouble()
    next()
    nextLine()

    Scanner class is available in java.util package.

    import java.util.Scanner;

    (or)

    type the fully qualified name.
    java.util.Scanner scan = new java.util.Scanner(System.in);



2) accept a day number. print the corresponding week day name.

0 - sunday
1 - monday
2 - tuesday

6  - saturday
invalid day number.

    System.in   refer to standard input device i.e., keyboard
    System.out  refer to standard output device i.e., VDU   (monitor)


class Test {
    public static void main(String [] args) {
        double height = 153.5;

        switch (height) {
            case 150 : System.out.println("Not accepted");
                       break;
            case 153 : System.out.println("considered");
                       break;
            case 153.5 : System.out.println("selected");
                        break;
        }
    }
}

switch will allow only certain datatypes.
1) byte, short, int, char, String, enum.
2) long, double, float, boolean are not allowed.

byte : 1 bytes
-128 to 127

byte b = 100;
int a = b;          // allowed.

3) accept two numbers and an arithmetic operator. perform the operation and print the result.

    10
    5
    /
    result : 2

15 minutes.


4) accept consumer number, last month reading, current month reading.
    calculate the electricity bill as per the following way ...

    no. of units                slab rate
    -------------------------------------------------------------------
        <= 100                  2.50 per unit
        
        > 100                   for first 100 units, 2.50 per unit
        <= 200                  next remaining units 3.00 per unit

        > 200                   for first 100 units, 2.50 per unit
                                for next 100 units, 3.00 per unit
                                for all remaining units, 3.50 per unit

    add Rs. 50 as fixed charges for each bill.

    print relevant details.

    20 minutes.

    jan 1       :   150  meter reading
    feb 1       :   250 meter reading

    feb bill : 250 - 150 = 100 units

    
Day - 2:
=============================================================================

int a = 10;
int b = a;
int c = 15;

switch (a) {
    case b : System.out.println("10");
             break;
    case c : System.out.println("15");
             break;
}

output:
--------
error : case expressions must be constant only, cannot be variables.


                                    loops
                                    ======
set of statements that are executed repeatedly.                                    -----

1) for
2) while
3) do..while
4) enhanced for loop

for:
----
statements are executed as long as the condition is true.
this is called as entry-tested or top-tested loop.

        [1]            [2]          [4]
for(initialization; condition; update expr) {
   statement(s);           [3]
   [break;] 
}


class Test {
    public static void main(String [] args) {
        for(int i = 1; i >= 10; i++) {
            System.out.println(i);
        }

    }
}

output:
-------
no output

is initilization is compulsory?
NO

int i = 1;
for( ; i >= 10; i++) {
    System.out.println(i);
}

is update expression is mandatory?
No

int i = 1;
for( ; i >= 10 ; ) {
    System.out.println(i);
}

is condition is mandatory?
No

for( ;  ; ) {
    System.out.println(i);
}

it will fall into an infinite loop. 

int i = 1;
for( ;  ; ) {
    System.out.println(i);
    if ( i == 10)
        break;
    i++;
}


5) Write a program to print all the factors of a given number.
eg: input : 12
    output : 
    1
    2
    3
    4
    6
    12

6) Write a program to print whether a given number is prime or not.
eg: input : 17
    output : prime

    input : 10
    output : composite

10 minutes.

7) write a program to print the following FLOYD triangles upto n rows.
eg: input : Enter no. of rows : 5
    output:

    1   2   3   4   5
        1   2   3   4
            1   2   3
                1   2
                    1

i => 1 to n

    s => 1 to i-1

    n   i       s
    --  --  -------
    5   1       0
        2       1
        3       2
        4       3
        5       4

                s = i - 1


        j =>    1 to n-i+1

        n   i       end of j
        --  --      ---------
        5   1           5
            2           4
            3           3
            4           2
            1           1

                    end of j = n - i + 1
                            5 - 2 + 1

for i = 1 to n {
    for s = 1 to i-1 {
        // print spaces
    }
    for j = 1 to n-i+1 {
        // print numbers

    }
}

8) write a program to accept numbers continuously till 0 is entered. findout the sum, average
of all these numbers.

int / int = int

10 / 2 = 5
10 / 3 = 3  

int / double = double
double / int = double
double / double  = double

10.0 / 3    =   3.3
10 / 3.0    =   3.3
10.0 / 3.0  =   3.3

type casting:
-------------
changing value from one type to other temporarily.
syntax:
-------
(datatype) var;

(double) sum / count
sum / (double) count


while:
------
    statements are executed repeatedly as long as the condition is true.
    this is called as entry-tested or top-tested loop.

syntax:
-------
    while (condition) {
        st-1;
        st-2;
        ....
        [break;]
    }

Factorial program:
    5! = 1 * 2 * 3 * 4 * 5 = 120

class Test {
    public static void main(String [] args) {
        Scanner scan = new Scanner(System.in);
        System.out.print("Enter number : ");
        int num = scan.nextInt();
        int fact = 1;
        for(int i = 2; i <= num; i++) {
            fact *= i;
        }
        System.out.println("Factorial : " + fact);
        scan.close();
    }
}

class Factorial {
    public static void main(String [] args) {
        Scanner scan = new Scanner(System.in);
        System.out.print("Enter number : ");
        int num = scan.nextInt();
        int fact = 1;

        int i = 2;
        while (i <= num) {
            fact *= i;
            i++;
        }
        
        System.out.println("Factorial : " + fact);
        scan.close();
    }
}

how can i choose between for & while?
-------------------------------------
    for loop should be used when you want to execute statement for a finite number of times.
    while loop should be used when you want to execute statements for in indefinite number of
    times.

write a program to enter numbers continuously until user press 0. findout the biggest
and smallest value among them.

10 mins.

for(;;) {

}

while(true) {

}

do .. while:
------------
statements are executed repeatedly as long as the condition is true.
this is called as exit-tested or bottom-tested loop.

do {
    st-1;
    st-2;
    ...
    [break;]
} while (condition);

it is generally used to write menu-driven programs.

what is the difference between break and continue?
--------------------------------------------------
whenever a break statement is encountered the control immediately comes out of the loop
without executing the remaining iterations.
whereas the continue statement will take you to the next iteration without executing the
remaining statements in the current iteration.


                                            arrays
                                            ======
linear collection of homogeneous data items stored under single name.
0 based index.
every array in java is an object.
array is provide a special property (field) with the name "length", that return no. of cells
in the memory.

if we try to access an element with an invalid index, leads to an exception.
"ArrayIndexOutOfBoundsException"

types of arrays:
-----------------
1) single dimension
2) multi-dimension
3) jagged 

single dimension:
-------------------
declaring:
----------
    datatype [] arrayName;
    (or)
    datatype arrayName[];

    just by declaring, no memory is allocated.

eg:
    int [] arr;

allocating memory:
------------------
    arrayName = new datatype[size];
eg:
    arr = new int[5];

    whenever we use "new" keyword, the memory is allocated dynamically and stored in a special
    memory area known as "heap".

declaring and allocating :
----------------------------
    datatype [] arrayName = new datatype[size];

eg:
    int [] arr = new int[5];

initialize an array:
---------------------
    int []  arr = {10,20,30,40,50}; 
    

class ArrayExample {
    public static void main(String [] args) {
        int [] arr = new int[5];

        for(int i = 0; i < 5; i++) {
            System.out.println(arr[i]);
        }
    }
}

int     -   default value   -   0
double  -                   -   0.0
String  -                   -   null
boolean -                   -   false


write a program to find min, max of an array.

enhanced for loop:
------------------
    there is no concept called "index".
	Enhanced for loop offer better performance than classic for loop.
	loop variable is not "int" unlike as in classic for loop.
	type of the loop variable is same as the type of array.
	We cannot process few elements in the array.

    it is used to traverse an entire array or a collection in forward-only direction.

    syntax:
    -------
        for(datatype variable : arrayName) {
            ...
        }

write a program to find number of ZEROs, EVENs and ODDs in an array.


Day-3
================================================================================

can we write multiple classes in a java file?
yes

can our class name and file name be different?
yes

is it mandatory to declare a class as public?
no

can we have multiple public classes in a java file?
no

can be the public class name and java file name are different?
no

what is the difference between a public class and non-public class?
...


linear search (sequential search) program.

sorting program (ascending order)
n = 5

(0) 50  20  20  20  20  20  20
(1) 20  50  35  27  27  27  27
(2) 35  35  50  50  41  35  35
(3) 41  41  41  41  50  50  41
(4) 27  27  27  35  35  41  50

i   j
--- ---
0   1
0   2
0   3
0   4
-----------
1   2
1   3
1   4
------------
2   3
2   4
------------
3   4
------------
n = 5

i : 0 to 3
    j : i+1 to 4

i : 0 to n-2
    j : i+1 to n-1

    a[i] > a[j]
        swap them


double dimension array:
-----------------------

            studentData
rollno      age     height      weight
1           ..      ..          ...
2
3



how do you declare?
    int [][] studentData = new int[3][4];

initialize?

    int [][] studentData = {
        {1, 25, 150, 60},
        {2, 21, 160, 45},
        {3, 19, 140, 36}
    };

every row in a double dimension array is treated as a single dimension array.

the "length" property of a double dimension array, always return no. of rows.
eg:
    studentData.length => 3
    studentData[0].length => 4
    studentData[1].length => 4
    studentData[2].length => 4

Jagged array:
-------------
It is also a double dimension array, where each row contain different number of columns.

eg:
    1   2
    3   4   5
    6   7   8   9
    10

int [][] jarr = {
    {1,2},
    {3,4,5},
    {6,7,8,9},
    {10}
}

                                        Command Line Arguments
                                        ----------------------

public static void main(String [] args) {

}

we cannot define main method like this ..
public static void main() {

}
it is treated as another method.


command line arguments are used to give inputs (parameters) to the main() method.
it is another way of accepting data.

write a program to print all command-line arguments.

write a program to accept two numbers and an arithmetic operation (ADD, SUB, MUL, DIV)
using command line arguments and perform the operation and print the result.

is int a primitive type ?	
		yes`
is String a primitive type?
		no
		String is a pre-defined class, it is a user-defined type.

How do you convert data of String to primitive type int?
    Integer -> parseInt(String form int)
    eg: 
        "10"    =>  Integer.parseInt("10") => 10
        "5"     =>  Integer.parseInt("5") => 5
        "ADD"   =>  

    Double.parseDouble(String form double)

        "10.5"  =>  Double.parseDouble("10.5") => 10.5
    
    for all illegal value, we get NumberFormatException.

Defensive programming:
----------------------
    avoid run-time errors using our logic.


                                            Functions
                                            =========

It is a sub program designed to perform a specific task that can be used repeatedly.
A function can have 0 or more inputs (arguments / parameters)
But a function can return 0 or 1 value only.

In java, we call functions as "methods".

Function components:
-----------------------
Function declaration    (function prototype)
Function definition     (function code)
Function call

Note:
In order to call a function in the main(), we should declare the function as static.
(or)
Create an object of the class, and access through the object.

formal parameters (formal arguments):
    paraameters given in the function definition.
actual parameters (actual arguments):
    parameters given in the function call.

function calling:
-----------------
1) call-by-value    (sending values)
        for all primitive types, the default mechanism is "call-by-value".
2) call-by-reference (seding references)
        for all objects, the default mechanism is "call-by-reference".


    x = 10       (x)   --->     fn()    --> x++
    x = 10        <------------------------------   call-by-value       
    x = 11        <------------------------------   call-by-reference

can you send array as parameter to function?
yes

can we return array from a function?
yes

write a function to return the reversed array of a given array.
(or)
write a function to accept an array and reverse the array itself and return the reveresed array.


    static void show(int x, double y, String z) {
        System.out.println(x + "\t" + y + "\t" + z);
    }

    public static void main(String [] args) {
        show(5, 10.5, "Java");
        show(5, 10.5);
        show(5);
        show();
    }

actual parameters (3)           formal parameters (3)
actual parameters (2)
actual parameters (1)
actual parameters (0)

rule:
-----
    no. of actual parameters = no. of formal parameters


        sum of few numbers.


        sum(10,20)      ==> 30
        sum(1,2,3,4,5)  ==> 15
        sum(3)          ==> 3

        int sum(int [] arr) {

        }


                                            VarArgs
                                            -------
Variable Arguments
    it represents indefinite number of arguments
    it is represented with ... (three dots)
    three dot symbol "ellipsis".

    we can pass any number of arguments while calling this type of function.

    Command Line Arguments can also be represeted as Variable Arguments.



                                        Function Overloading
                                        ---------------------
when two or more functions are having the same name but with different set of parameters ,
the it is said to be function overloading.

int area(int a, int b) {

}

int area(int a, double b) {

}       // allowed

int area(double a, int b) {

}   // allowed

double area(int a, int b) {

}   // NOT ALLOWED - return type is not considered


                                        Recursion
                                        ----------
calling the same function being in itself.

            int factorial(int  num) {
                if (num == 0) {
                    return 1;
                } else {
                    return num*factorial(num-1);
                }
            }


Day - 4
------------------------------------------------------------------------------

    int [] arr1 = {10,20,30,40,50};
    int [] arr2 = arr1;             // valid 
    System.out.println(arr1);       // values are not displayed. reference is displayed.
    System.out.println(arr2);

    for(int i = 0; i < 5; i++) {
        arr1[i]++;
    }

    for(int val : arr1) {
        System.out.println(val);
    }                               // 11,21,31,41,51

    for(int val : arr2) {
        System.out.println(val);    // 11,21,31,41,51
    }


Arrays class: (java.util package)
----------------------------------
provide many util methods to simplify our programming.
explore these methods.

1) copyOf()
2) binarySearch()
3) sort()
4) fill()

whenever we == on arrays to check for equality, references are compared, not data.

5) equals()
6) deepEquals()


                                OOPS (Object Oriented Programming System)
                                =========================================
It is a programming paradigm.

1) monolithic   : Assembly language
2) procedure oriented   :   COBOL
3) structured   :   'C'
4) object oriented 
    +   data is given more importance than logic
    +   object contain it's own data and related operations


OOAD        (Object Oriented Analysis and Design)
-------------------------------------------------
    class diagram
    use case diagram
    sequence diagram

    actor

class   :  it is a user-defined datatype that represent an entity in terms of properties
           (variables / fields / data members) and behaviours (methods).
           it is a re-usable software component.

           classes we are going to create also called as models, pojos, beans etc.,
           POJO (plain old java object)

object  :  it is the entity itself.

Employee
    id
    name
    dateJoined
    salary

state:
    whenever an operation is done on the object, properties will change. this is called 
    state is modified.

Account
    id : 101            name : srinivas         balance : 10000     (current statement)

            operation (deposit - 5000)

                                                balance : 15000     (new state)

datatype    <---    value
int = 50;

datatype    <--     variable    <-- value

Employee    <--     object         <--  data


define a class:
-----------------
class   ClassName {
    datatype dataMember1;
    returnType method1() {

    }
    returnType method2() {

    }
}

No memory is allocated when we define a class.

declare an object:
------------------
className   objectName = new className();

the "new" keyword allocate memory for an object.

features:
---------
1) Encapsulation
        nothing but data hiding.
        providing setters (mutators) and getters (accessors) to access private data members
        to other classes.
        setters are used to provide initial value or to modify existing value of a data member.
        getters are used to retrieve current value of data members.


2) Abstraction
        nothing but behaviour hiding.
3) Data hiding:
        make data members as private.
        so that they are not accessible from outside of the class.
        

ComplexNumber
    realPart
    imaginaryPart

Access Specifiers (Access modifiers)
-------------------------------------
1) default : which is taken when no specific access is given on members.
    any member under default can be accessed only in the current package.
2) private : members under this access can be used only within the class in which they
             are declared.
3) public  : members under this access can be used everywhere, wherever the package is visible.
4) protected : members under this access can be used either within the class or any of it's
             sub class.

"this" reference:
-----------------
it refer to "implied object".
implied object is the object is the one, on which the current method is called.

Constructor
---------------
It is a special method which is automatically executed whenever an object is created.
It is used to initialize data members.
It should have same name as that of class.
A class can have many constructors. this feature is called "constructor overloading".
It cannot return any value, and should not be marked as void.

this() is also used to call a constructor from another constructor of the same class.   

public class Test {

	public Test() {
		this("hello, how are you?");
		System.out.println("default constructor");

	}
	
	public Test(String msg) {
		System.out.println(msg);
	}
	
	public static void main(String [] args) {
		Test t = new Test();
	}

}

if no constructor is defined, java itself insert a default constructor to the class internally.
if at all you write atleast one constructor, java will not insert any constructor.

types of contructors:
-----------------------
1) default constructors     (no-parameter constructor)
2) parameter constructor    (parameterized / parametric constructor)
3) copy constructor:
    it takes object of the same class as parameter.
    it is automatically executed whenever we are creating a new object by passing an
    existing object as a parameter.

class  Student {
    private int rollNumber;
    private String name;
    private static int feePaid;

    public Student(int rollNumber, String name) {       // parameter constructor
        this.rollNumber = rollNumber;
        this.name = name;
    }

    /* setters are getters */
}

class StundentApp {
    public static void main(String [] args) {
        Student s1 = new Student();     // it is expecting default constructor
        System.out.println(s1.getRollNumber() + "\t" + s1.getName());
    }
}

since the above class do not have a default constructor, we can create object by
    Student s1 = new Stundent();

Student s2 = new Student(2, "deepa");  // perfectly valid

include the default constructor.

    public Student() {
        /* intentionally left blank */
    }


"static" keyword:
-----------------

It can be used in different ways.
a) static data members	(when a data member is declared with "static" keyword)
b) static methods		(when a  method is defined with "static" keyword)
c) static block		(block means a group of statements enclosed within curly braces)
d) static class		(when a  class is defined with "static" keyword - inner class)


static data members:
---------------------
	data member that is declared with "static keyword" is also called "class variables".
	data members that are declared "without static", are called "instance variables".
	every object of a class have independent copies of instance variables (data members) 
    and they all share the same copy of class variable.
    it is used to store common data of all objects of the class.

static methods:
---------------
	a static method can make use of other static members (data members or methods) directly.
	"this" keyword cannot be used in static method.
	
    we can call a static method directly with the class name, not with any object.

    className.staticMethodName();

    class           methods
                    --------
    Scanner         nextInt()
                    nextDouble()

    create an object for the Scanner class
    Scanner scan = new Scanner(System.in);

    objectName.methodName()

    scan.nextInt();

    class           static method
    ------          -------------
    Integer         parseInt()
    Double          parseDouble()

            Integer.parseInt()
            Double.parseDouble()

    Math            pow()
                    sqrt()
                    PI          // static data member (or) static field

                    Math.PI
                    Math.sqrt()
                    Math.pow()
                    Math.abs()


	PUBLIC STATIC members of a class can be accessed directly with class name. 
    we do not need to have any object.

static block:
---------------
	static {
		st-1;
		st-2;
		......
	}

	a class can have only one static block.
	static block gets executed whenever the class is accessed for the first time.
	a class is said to be accessed if ....
	1. declare a refernce
    2. allocated an object
    3. call a static method
    4. refer a static field.
    5. any of the above on one of its sub-classes.

polymorphism:
-------------------
	poly means "many".
	morph means "forms"

	It is a behaviour of an entity.
	different behaviours with the same name.

	class	Human {

		public Energy eat(IceCream  ic) {
			Energy energy = 0;
			while (ic is still left) {
				energy += lick(ic);
			}	
			return energy;
		}
		
		public Energy eat(Apple  apple) {
			Energy energy = 0;
			while (apple is still left) {
				energy += chewAndSwallow(apple);
			}	
			return energy;
		}
	}

	eat() is exhibiting polymorphism.


	class	ArithmeticOperation {
		multiply(int a, int b)  {
			return a*b;
		}
		multiply(Complex a, Complex b) {
			// different code
		}
		multiply(Matrix a, Matrix b) {
			// different code
		}
		multiply(Polynomial a, Polynomial b) {
			// different code
		}	
	}

	multiply() is exhibiting polymorphism.

	overloading:  (compile-time polymorphism or early-binding)
	-----------------------------------------------------------
		when two are more methods are said to be overloaded when ....
		i) they must share the same name
		ii) they belong to the same class (or) to a super class and sub class
		iii) they differ in no. of parameters (or) parameter types.

		example: eat(), multiply()
		
	overriding:  (run-time polymorphism or late-binding)
	-----------------------------------------------------
		two methods are said to be overridden when ...
		i) they share the same signature	
		  (signature means method name, return type, argument list)
		ii) they belong to super class and sub class

        we can use @Override annotation to specify that the method is going to be overriding
        the super class method.
        
        the compiler will give an error if the signature is not matching with super class 
        method.



java.lang.Object class:
------------------------------
	Every class in java whether is pre-defined or user-defined, inherited from java.lang.Object 
    class.
	It is called "universal super class" (cosmic class)

	methods of java.lang.Object class:
	---------------------------------------------
	1) public String toString()
		it converts an object into String.

	the default implementation is to return the hashcode.
	System.out.println(object)	: display the hashcode in hexa decimal system.
	System.out.println(object.toString()) is same as previous statement.

	But whenever we want to print the object, we want to display properies of an object. 
    In such case, we must override toString() method.

    2) int hashcode()
        it return the hash code in decimal system.

    Stack and Heap memory
    ------------------------
    Student s = new Student();
    variable s ->  in stack memory -> hashcode
    object memory -> in heap memory -> data



Day - 5
----------------------------------------------------------------------------

Inheritance:

	creating a new class (sub class) from an existing class (super class).
    sub class can make use of all features of super class as well as any extra features that are
    added to it.
    it represent "is-A" relation ship.
    it is mainly for code-reusability.

	types of inheritance:
	----------------------------
	1) simple		2) hierarchical	    3) multi-level  4) multiple	    5) hybrid
	
    the keyword "extends" is used to derive a sub class from a super class.
	java doesn't support multiple inheritance for classes that means a class can have only one
    superclass.
	
    Note:
    ------
	Inheritance will share only the definition but not the existence.



CASE STUDY:
-------------------------------
Person
    name, age
    setters, getters, constructors, toString
Employee    (is a Person)       [simple]
    salary
    setters, getters, constructors, toString
Manager		(is a Employee)		[multi-level]
	allowance
    setters, getters, constructors, toString
	
ContractEmployee	(is also an Employee)			[hierarchical]
	contractDuration

constructor phenomenon:
----------------------------------
	when an object is created, the constructor of that class is called.

	when an object of sub class is created, super class constructor is called first and 
    then the sub class constructor is called. This hold true for any levels of inheritance.

	when a sub class object is created with

	i) default constructor		then the super class default constructor is called.
	ii) parameter constructor	then the super class default constructor is called.
	iii) copy constructor		then the super class default constructor is called.

"super" keyword:	("super" reference)
----------------------------------------------------
	1) it is used to call the constructor of super class from the constructor of sub class.
	2) This is used exclusively call a parameter constructor or copy constructor of the 
        super class from sub class constructor.
	3) if super() has to be used, it must be the first statement in the code block.
	4) this() and super() cannot be used at a time.	(mutually exclusive)
	5) "super" can be used to call an overriding function of super class in the sub class.

class A {
    public A() {
        System.out.println("A");
    }
}
class B extends A {
    public B() {
        System.out.println("B");
    }
    public B(String msg) {
        System.out.println(msg);
    }
    public B(B obj) {
        System.out.println("copy constructor");
    }
}
class C extends B {
    public C() {
        System.out.println("C");
    }
}
class Main {
    public static void main(String [] args) {
        B obj2 = new B(obj);
    }
}


Abstract Polymorphism	(Abstraction)
---------------------------------------------------------
abstract means "incomplete or unclear". It is an idea but we don't know how to implement.
abstraction means "behaviour hiding".
abstraction is "disclosing only required details and hiding the background implementation".

abstract class:
--------------------
	It is a class which should not have objects allocated.

	School Automation
		School	=> Domain
		Teacher, Student, Principle	=> Domain Entities
	
		common properties	=>  

		Person ==> name, age, phone, address, date of birth, weght, height, blood group

		Teacher extends Person	    => salary, subject, 
		Principle extends Person	==>	....
		Student extends Person      ==> fee, class, section

        In this scenario, we never need to create an object for Person.
        so, Person class can be declared as an abstract.

	to make a class abstract, it must be defined with an "abstract" keyword.
	we cannot instantiate (create an object) an abstract class.

abstract method:
----------------------
	It is a method which do not have any implementation (i.e., definition)

   	eg:	abstract class Shape 
			abstract 	area()	: 
			abstract 	perimeter() :
			abstract	volume();


	    abstract class	Rectangle	extends	Shape {
			@Override
			area() {
				...
			}
			@Override
			perimeter() {
				..
			}
		}

		class	Cuboid	extends	Rectangle {
			@Override
			volume() {
				....
			}
		}

	1) an abstract method must be written only inside an abstract class.
	2) but an abstract class need not contain an abstract method.
	3) all sub classes of abstract class, must implement (override) all abstract methods. 
       if not, the sub class must also be marked as "abstract".

abstract class A {
    abstract void show();
}

class B extends A {
    @Override
    protected void show() {               
        System.out.println("B");
    }
}

class Test {
    public static void main(String [] args) {
        B obj = new B();
        obj.show();
    }
}

error:
    cannot reduce the visibility of the inherited method.

Visibility Levels:
---------------------------------------------
private             (least visiblity)
default             (it can be used in any class belong to the current package)
protected           (it is visible to current class as wells as in any of
                    sub classes)
public              (every where)
---------------------------------------------

Referencing:
------------

	In inheritance, super class reference variable can hold sub class objects.
	Vice Versa  is NOT TRUE.

			                    Employee
			                        |
            --------------------------------------------
	        |					                        |
         Manager				                ContractEmployee
	        |
       Managing Director

	Employee emp1 = new Employee();		// OK
	Employee emp2 = new Manager();		// OK
	Employee emp3 = new ContractEmployee();	// OK
	Employee emp4 = new ManagingDirector();	// OK
	
	Manager m1 = new Manager();		// OK
	Manager m2 = new ManagingDirector();		// OK
	
	Manager m3 = new ContractEmployee();	// Not OK
	
	ContractEmployee ce = new Employee();	// Not OK


	Type Casting:
	------------------
	Converting one datatype to another.

	2 types.

	a) Narrowing	(demotion)		explicit
	b) Broadening	(promotion)		implicit


	primitve types:
	-------------------
	b) broadening:
	    -----------------
	int x = 45;
	double d = x;		(implicit)	- broadening

	double d2 = 67;		// OK
	int y = '@';		// OK

	char -> int -> double

	a) narrowing: (explicit):
	------------------------------
	int x = 45.0;		// error
	int x = (int)45.0;		// OK

	char ch = (char)156;	// OK


	user-defined data types:
	-----------------------------------------

	ContractEmployee ce1 = new Employee();		// Not OK
	ContractEmployee ce2 = emp3;			// Not OK

	ContractEmployee ce2 = (ContractEmployee)emp3	// OK
	
	ContractEmployee ce3 = emp4;			// Not OK
	ContractEmployee ce2 = (ContractEmployee)emp4	// Not OK  - we get ClassCastException

	Manager m1 = (Manager)emp2;			// OK
	Manager m2 = (Manager)emp3;			// Not OK
	Manager m3 = (Manager)emp4;			// OK

	
Dynamic Polymorphism:
--------------------------------
With all abstract functions, there will be multiple implementations. Here the dynamic 
polymorphism is implemented.

final keyword:
------------------
1) final class : it cannot be inherited.
2) final method : it cannot be overridden.
3) final variable : value of which cannot be modified. (constants)

class A {
    public final void show() {
        System.out.println("Final method");
    }
}
class B extends A{
    void show() {           // not allowed - since show() is a final method
        System.out.println("overridng");
    }
}



final class C {
    ..
}
class D extends C {     // not allowed - since C is a final class

}


Note:
-------
The abstract and final cannot appear at the same time since  they are 
mutually exclusive (It is called as Definition Constradictory)

Best Practices:
--------------------
whenever we create a constant, it is recommended to mark it as "public static final".
	final because ,it must be a constant.
	static because a constant will have only value for all objects of the class.
	public because however it cannot be modified.

eg:
	public class Circle {
		private double radius;
		public static final double PIE = 3.14;

		/* setters and getters */
	}	


class               : entity
abstract class      : semi-defined entity
interface           : ROLE (responsibility)

interfaces:
-----------
It is a user-defined datatype (like class) that represents a ROLE and can contain 
only abstract methods and static final variables (till JDK 1.7)
interface will not have properties.
we cannot instantiate an interface.

					    Living Being  (Entity)
			        		        |
	        |---------------------------------------------------------|
	    Human  (Entity)							                Animal  (Entity)
     |-----------------------------|						|---------------|
Male			                Female					Male		      Female


				Mother (role)	birth_to_baby(), feed_baby()
				Father  (role)	protect_child()
				Brother (role)
				Sister  (role)

one entity can play multiple roles. This is how we can achieve  multiple inheritance 
using interfaces.

class Human implements Mother, Sister {
	..
}

class Human implements Father, Brother {
	..
}

class Human implements Father {		//  if father is interface

}

class Human extends Father {			// if father is class

}

super class         <--- extends    --> sub class
interface           <--- implements ---> sub class`
interface           <--- extends ------> sub-interface

why can't we use abstract classes instead of interfaces?

one entity can play multiple roles.
if we use abstract classes, we can't achieve this. because we cannot have two super classes 
for a single class. that's why we must use interfaces.
when multiple inheritance is not required, we can go with abstract classes. 

abstract class
    can it have normal methods ?
    YES.
    can it have abstract methods ?
    YES
interface
    can it have normal methods ?
    NO
    it should have only abstract methods.

Note:
-------
1) The keyword "extends" is used to derive a class from a class or an interface from
   another interface.
2) The keyword "implements" is used to derive a class from an interface.
3) It is not possible to derive an interface from a class.
4) A class cannot have many super classes.
5) But a class can have more than one super interfaces, (multiple inheritance)
6) We need not mark method declarations inside an interface as "public abstract". 
   However there are automatically treated as public abstract.
7) We can create one interface from multiple interfaces.

    interface One {
        ..
    }

    interface Two {
        ...
    }

    interface Three extends One, Two {
        // very much possible
    }

when do we use interfaces?
1) interface works as an abstract bridge between two modules.
2) interface brings only behaviourally similar entities under one hierarchy.

	Rocket		Bird		AirPlane
		all of the above entites can land(), takeoff(), fly()

	only these behaviours are common nothing else.
	properties are not common.
	to bring them under one roof, we can create an interface.

	interface	IFlyingObject {
		void land();
		void takeoff();
		void fly();
	}

	class	Bird 	implements  IFlyingObject {
		// provide implementations for all abstract methods.
	}

	class	Rocket 	implements  IFlyingObject {
		// provide implementations for all abstract methods.
	}

	class	AirPlane 	implements  IFlyingObject {
		// provide implementations for all abstract methods.
	}


 interface                      Abstract Class
 ------------------             -------------------
 no fields                          have fields
 only public members                any type of members
 
 represent Role                 represent Entity (semi-defined)
 and one entity can 
 have any number of roles






Day-6
========================================================================

Painting Store ----------- EstimationApp

 estimate the cost of painting an Hoarding
 area * paintingRatePerUnit

 estimate the cost of bordering a Hoarding
 perimeter * borderingRatePerUnit

 the Hoarding are not always rectangle in shape,
 they cen be circular or traingular ..etc.,


 interface Hoarding
 getArea()
 getPerimeter()
 |
 |-CircularHoarding
 |-RectangleHoarding class EstimationService{
    public double estimateCost(Hoarding h){
        h.getArea()*67.8;
    }
 }
 
enum:
------

"enum" in java is a user data type that contain fixed set of constants.
"enum" stands for "enumeration".
it is a user-defined datatype that represent possible values of a property.

It can be used for day of the week (SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY and SATURDAY) , 
directions (NORTH, SOUTH, EAST and WEST), Season (WINTER, SPRING, SUMMER, FALL), gender (MALE, FEMALE)   etc. 

The java enum constants are static and final implicitly. 

Java Enums can be thought of as classes that have fixed set of constants.

enum ensures type safety.

methods:
---------
1) values()
2) ordinal()
3) name()


 
static class

 Not all classes can be static.

 Java allows us to create a class inside another class
 only such inner class can be marked as static, 
 adn static inner classes are called nested classes.

 class Demo{
    class InnerClass{

    }

    static class NestedClass{

    }
 }


Java 8 enhancements to an interface.
------------------------------------
 default methods

 unlike method in a interface that are forced to be abstract,
 if a method is marked with keyword 'default', then the
 default method can have implementation

 interface A {
    public abstract void m1();
    public abstract void m2();


   default void m3() {
       // implementation code
   }

   static void m4() {

   }

 }

 class B implements A {
     @Overriding
     void m1() {

     }

     @Overiding
     void m2() {

     }

     @Override
     void m3() {
         // sub class specific
     }
 }

 B obj = new B();
 obj.m1()
 obj.m2()
 obj.m3()

 A.m4()     ==> since m4 is static method, we can call by using interface name.



 100 implementation classes 



						                Built-In Packages
						                ------------------
                                        (Java SE Libraries)

java.lang			(default package - because it is imported for every program)
	Object          
	System
	Math
	String
	StringBuffer
	StringBuilder
	Exception
	Throwable interface
	Runnable interface
	Thread
	Wrapper classes - Integer, Double, Float, Long, Boolean


java.time	(JDK 1.8)
	LocalDate
	LocalTime
	LocalDateTime
	DateTimeFormatter
	Duration
	Period

java.util
    Scanner

java.io
    BufferedReader

to use any class, we need to specify fully qualified class name.(eg: packagename.classname) 
or import them.

java.lang is the default package. it is automatically imported for every program.

java.lang.Object
----------------------
	It is the universal super class (cosmic class).

	methods:
	------------
	public int hashCode()
	public boolean equals(Object)
	public String toString()


	equals(Object):
		if (obj1 == obj2)		means it compare hash codes.
		if (obj1.equals(obj2))	return if magnitudes are equal, otherwise false.

	they have return bit-wise comparision. but to have our own logic, we need to override this method.

	"@Override" annotation:	It is an instruction given to source analyzer (i.e., compilers, document generator etc.,)
				It is a compile-time check instruction. It is used to verify whether the overriding is done properly or not.
				The compiler will give an error if it is not overridden properly.

2) java.lang.System class:
   -------------------------------

	class variables			        object
	-------------------				---------
	public static InputStream		in
	public static PrintStream		out
	public static PrintStream		err

	System.in	carries signal from keyboard to VDU.
	System.out, System.err carries signal directly to VDU.


	methods:
	------------
	public static void gc();		request for garbage collection.
	public static void exit(int)	terminates the program then and there. int could be either a 0 or 1.
    String getEnvironmentVariable(String varName);
    void setEnvironmentVariable(String varName,String value);



java.lang.Math
-------------------
	public static fields:
	------------------------
		E, PI
    	
	public static methods
	----------------------------
		double pow()
		double sin(angle in radians)
            Math.sin(30)    =>  ???
            Math.sin(Math.toRadians(30))    =>  0.5

        double cos(angle in radians)
		double sqrt()

		ceil() : return next integer
            Math.ceil(11.2) => 12
		floor() : return previous integer
            Math.floor(11.9) => 11
		round() 
            Math.round(11.2) =>  11
            Math.round(11.9) =>  12

		abs()
		toRadians()
		toDegrees()

java.lang.String
---------------------
	String is immutable	(not modifiable).

	creating object:
	---------------------
	1) String	str;
	2) String	str = new String();
	3) String	str = "hello";
	4) String	str = new String("hello");
	5) String	str1 = str;
	6) String	str1 = new String(str);


	methods:
	-------------
	1) length()		2) toUpperCase()		3) toLowerCase()
	4) indexOf(String)	5) lastIndexOf(String)		6) startsWith(String)
	7) endsWith(String)	8) contains(String)		9) charAt(index)
	10) substring(start_index [, end_index] )		11) split()
	12) equals(String)	13) equalsIgnoreCase(String)	14) compareTo(String)
	15) valueOf()		16) format()        17) replace(old_char, new_char)

    18) join()  - JDK 1.8

    "+" string concatenation operator


String constant pool (String literal pool)
------------------------------------------
    This is a special memory used to store string constants.


java.lang.StringBuffer and java.lang.StringBuilder:
------------------------------------------------------------------
	StringBuffer is thread-safe. (synchronized)
	StringBuilder is not thread-safe.

	They are mutable (modifiable).

	a) capacity()
	b) append()
	c) insert()
	d) replace()
	e) delete()
	f) reverse()

StringJoiner (jdk 1.8)
    used to join group of statments.

    StringJoiner(delimiter)
    StringJoiner(delimiter, prefix, suffix)
    merge()

StringTokenizer (java.util)  
    to split the string into words based on the delimiter given.

    StringTokenizer(string, delimiter, boolean returnDelims)

    hasTokens()
    nextToken()

    Since it is a legacy class, we can use split() of String class, which offer better
    performance.




Wrapper Classes                     static method
    java.lang.Integer               parseInt(string-form-int)
    java.lang.Short
    java.lang.Byte
    java.lang.Double                parseDouble(string-form-double)
    java.lang.Boolean
    java.lang.Float
    java.lang.Character
    java.lang.Long

 Boxing:
    primitive variable into a wrapper object

    int x = 89;
    Integer iobj = x;   //auto-boxing

 unBoxing:
    wrapper object into primitive variable
 
    Integer iobj = new Integer(109);
    int x = iobj; // auto-unboxing


    String s="10";
    int x = Integer.pareInt(s);


Day - 7
===============================================================================

Exception Handling
--------------------------------

    Exception is an object
    that represents a situation
    where the application broke down.

                java.lang.Throwable (i)
                        |
                        |
            ---------------------------------
            |                               |
            java.lang.Error         java.lang.Exception
                                            |
                                            |
                                    java.lang.RuntimeException



    1) try : contain the code where the exception can be generated.
    2) catch : contain statements that are to be executed when the specified exception occurred.
            
            the most relevant exception classes mention first.
            least relevant exception mention next.

    a try block must follow an immediate catch block (or) a finally block.

            try {
                ..
            } finally {
                ...
            }

    a try can have many catch blocks.
    a try block can have another try block within it.

    3) finally : contain the code to be executed whether an exception or occurred or not.


    UnChecked Exceptions

        all exception classes that are
        dereived from RuntimeException class are
        identified as UnChecked.

        unchecked exceptions are 
        NOT INFORMED BY
        THE COMPILER. 

        we are not supposed to handle UnChecked Exceptions
        because they can be avoided through 
        "Defensive programming".

            Employee emp;
            emp = new Employee();
            emp.setName("Lavanya"); //NullPointerException is avoided.

                public void processHike(Employee emp){
                    if(emp!=null){
                        emp.setBasic(emp.getBasic()+10000); // NullPointerException is avoided
                    }
                }

        
        Checked Exceptions

            all exception classes that are NOT
            dereived from RuntimeException class are
            identified as Checked exceptions.
        
            if you not handle checked exceptions, the compiler will give errors.

            if a method is supposed to raise
            checked exception, the compiler will
            forces to handle checked exceptions

            checked exceptions must be handled, they cannot be avoided.

            eg:
                download a file, IOException
                database connection broken.   SQLException

                try{
                    ....the code that may raise an exception     
                } catch(Exception exp){
                    ..do the alternate or display a user understandable message.
                }


        user Defined Excepitons

            1. create a class which should be derived from java.lang.Exception
            2. write a constructor that takes a String parameter.
            3. call the super class constructor by passing this String to it.

            create a checked exception
            
            class MyCheckedException extends Exception {
                  
                MyCheckedException(String errMsg){
                    super(errMsg);
                }
            }

            create an unchecked exception

            1. create a class which should be derived from java.lang.RuntimeException
            2. write a constructor that takes a String parameter.
            3. call the super class constructor by passing this String to it.

            class MyUnCheckedException extends RuntimeException {
                  
                MyUnCheckedException(String errMsg){
                    super(errMsg);
                }
            }

            "throw" keyword is used to raise an exception
                throw new MyCheckedException("error message");

            "throws" keyword is used to tranfer the exception
            from a method to its caller method.


    String getMessage()         (java.lang.Throwable)
	void printStackTrace()      (java.lang.Throwable)



JDK 7 Enhancements:
---------------------------------
a) multi-catch exception

    try {
	    statement(s)
    } catch (Exception-1   |  Exception-2  |  Exception-3    obj) {
	    statement(s)
    }

b) try-with-resources

    try(declare closable resourceses here....){
                    ........................
    }catch(....){

    }

    the closable resource will be clsoe automatically.

    a Resource has to implement java.lang.Closable interface
    to be recognized as closable.

static import: (JDK 1.5)
------------------------
    Math
        sqrt()
        abs()
        pow()

    int a, b;
    double hypotenuse = Math.sqrt(Math.pow(a,2) + Math.pow(b,2));

    (or)
    import static java.lang.Math.sqrt;
    import static java.lang.Math.pow;

    double hypotenuse = sqrt(pow(a,2) + pow(b,2));


java.time package (JDK 8)
-------------------------
    LocalDate
        default format is yyyy-MM-dd.

        now() : static method that return system date.
        of(year, month, day)
        parse(string-form-date)

        getDayOfMonth()
        getDayOfYear()
        getMonthValue()
        getYear()

        plusDays()
        plusMonths()
        plusYears()

        now(), of(), parse() are known as "Factory method", which will return object of the same class.

    LocalTime
    LocalDateTime

    DateTimeFormatter
        format()
        ofPattern(formatString)
    Duration
    Period
        between(localDate1, localDate2)
        getDays()
        getMonths()
        getYears()

    ZoneId
        of()

    DateTimeFormatter                                        
        .ofPattern(String pattern);

            d           day                             
            dd          day with leading zeros          
            ddd         day in words

            M           month
            MM          month with leading zeros
            MMM         Three lettered Month name
            MMMM        comple month name

            yy , yyyy   Year

            h,hh        hour in 12 hr format
            H,HH        hour in 24 hr format

            mm          min

            ss          sec



                                   Regular Expressions
						           --------------------
                                    (java.util.regex)

A regular expression defines a search pattern for strings. The short form for regular expression 
is regex. 
The search pattern can be anything from a simple character, a fixed string or a complex 
expression containing special characters describing the pattern. 
The pattern defined by the regex may match one or several times or not at all for a 
given string.
Regular expressions can be used to search, edit and manipulate text.
It is mainly for validations.


	.	any single character
	\d	single digit from 0 - 9
	\D	single character except digit
	\s	space
	\S	single character except space
	[ ]	single character of given choice or range
		eg: 	[A-Z]           any uppercase alphabet
			    [abcdA-E]       a,b,c,d,A,B,C,D,E
			    [0-9]           any digit
	[^ ]	single character except within the range
		eg:	[^ 1-5]         any digit other than 1,2,3,4,5

occurance indicaters:
	
	?	0 to 1 time
	*	0 to any no. of times
	+	1 to any no. of times
	{ n }	exactly 'n' times.
	{ , m}	max. 'm' times and min. is '0'.
	{n, m}	min. 'n' times and max. is 'm' times.

eg:

	mobile number	"\d{10}"
	but in java, we must say "\\d{10}"

	but first digit cannot be 0. so , it must be given as ...	"[1-9]\\d{9}"

	vehicle number	eg: AP31 CK 9916
				        AP31CK   1
        [1-9]

		[A-Z]{2} \d{2} [A-Z]{2} \s\d{, 3}

	aadhar id		eg: 8414 6320 8422
		\d{4} \s \d{4} \s \d{4}


java.util.regex package:
------------------------------

a) Pattern class:		to represent regular expression.
-----------------------
	methods:
	-------------
	i)	public static 	Pattern 	compile(String   regexPattern)
			it checks whether any small part of pattern is matching or not.
	ii) public static   Matcher 	matches(pattern, String)
			it checks whether the entire string should exactly match the pattern.
    iii) String [] split(String)
            will extract the String based on the pattern specified.


Day - 8
-----------------------------------------------------------


                                    Generics
							        --------
These are called as ADT	(abstract data types)

when there is a logic which is indepedent of datatypes, then we can use ADT. 
eg: Sorting on int's, float's, double's or char's are same.
generics are implemented using angular bracktes. < >. The imaginary datatype is represented as T. 
eg: <T>.
if we have two imaginary datatypes then <T1, T2>

generics do not support primitive types.
T can be Book, Car, ComplexNumber, Employee etc.,
but not with int, char, float, double.
if it is inevitable, we may use Wrapper classes.


                                    Collection API
                                    ---------------
                                    (java.util package)

API  (Application Programming Interface)
    It is a group of pre-defined interfaces, abstract classes.
    They provided implementation classes also.


It is a structured way of storing group of objects.

Collection means group of objects
There are two types of data structures

Linear:  
	Objects are stored in a linear fashion
	Objects can be numbered which we call as index
	Linear data structure supports index based operations.

Advantages:
	Linear data structure supports sequential access 
	Also Supports random access.

Non linear:
    Not in linear fashion so we do not have index here and 
    thus we cannot access them randomly.

Few of the classes are grouped into collection

Collections are divided into 3 parts:
	
	a) Declaration Part: 
	Here we have interfaces 

                               Collection API Diagram
	b) Implementation part: 
		Set<-- HashSet,LinkedHashSet.
		SortedSet<---------Treeset
		List<------ArrayList,LinkedList


	Collection interface methods:
       	{ size(), contains(object), add(object), remove(object) }

    List allow duplicate elements.
	ArrayList-->interally uses an expandable array to store the elements.
	If there are too many insertions and deletions LinkedList is used.
	If there are too many retrievals arrayList will perform better.
    Vector is a legacy class.

    ArrayList class
        DEFAULT_CAPACITY = 10
        elementData is an Object[] where the data of array list is stored.
        everytime the grow() method is called, the array is extended by 50%.
        newCapacity = oldCapacity + (oldCapacity >> 1);

        methods:
        --------
        add()
        isEmpty()
        size()
        remove(index)
        set(index, value)
        get(index)
        clear()
        equals()
        indexOf(value)
        lastIndexOf()
        toArray() : convert array list into an array.
        sort()

    LinkedList:
    -----------
        it is in the form of linked list.
        it can be used when you are having frequent updations.

        1) addFirst()
        2) addLast()
        3) removeFirst()
        4) removeLast()

    Vector:
    -------
        default capacity = 10
        when a new elements is added when the existing cells are filled, the capacity is
        DOUBLED.

    What is the difference between Vector and ArrayList?

    Iterator:
        which allows to iterate through a collection.

        iterator()
        hasNext()
        next()

    What is the difference between iterator and enhanced for?


Set:
-------
    Set will not allow duplicate elements where as list will allow the same.

	HashSet --> Order is undefined.
	LinkedHashSet--> Insertion Order
	TreeSet-> maintains sorted order
        null is not allowed in TreeSet. we get NullPointerException.

    index based retrieval is not possible.

Queue:
    FIFO    (first in, first out)
    insertions will happen at begining.
    deletions also happend at beginning.
PriorityQueue

ArrayDequeue



Map:
------
			  Map Diagram 

	Maps are used to store key-value pair data. (It is also called as Dictionary)
	In map, keys are not sorted in order
	In sorted map, keys are in sorted order 
    key cannot be duplicated.
    value can be duplicated.
	index based retrieval is not possible.
    value can be retrieved if a key is given.

    put(key,value)
    get(key)
    set(key,value)
    remove(key)
    size()
    contains(key)
    keySet() : return all keys
    values() : return all values
    containsKey()
    containsValue()
    entrySet() : entry means combination of key and value
    

    implementation classes:
        HashMap
        LinkedHashMap
        TreeMap
        HashTable


java.util.Collections class:
----------------------------
1) sort()
2) binarySearch(list, key)
3) fill(list, object)

    java.lang.Comparable interface:
    --------------------------------
    it contain only one abstract method
    
    public int compareTo(T object)

    The class should know how do you want to sort.  (intenally)
    The class must implement java.lang.Comparable interface.



    Functional Interface:  (jdk 1.8)
    --------------------------------
        It is an interface that contain only one abstract method.
        it can be marked with @FunctionalInterface annotation.
        so that compiler will not allow you to add any extra methods later.

    Comparator (java.util) 
    -----------------------
    int compare(T object1, T object2)

        These are also used to apply sorting behaviour externally on a class.
        Create any class which should be inherited from Comparator interface.
        override the compare() by writing our own sorting logic.
        if we want to implement multiple sorting strategies we can use this.

    How does a collection (Set) identify duplicates?
        if two objects return true when the equals() method is applied, 
        they are considered as duplicates. In such case the later one is ignored.

    Student s1 = new Student(1, "srinivas", 18);
    Student s2 = new Student(1, "srinivas", 18);

    Set<Student> studentSet = new HashSet<>();
    studentSet.add(s1);
    studentSet.add(s2);

    System.out.println(s1 == s2);       // false
    System.out.println(s1.equals(s2));  // false

    System.out.println(student.size());     // 2

    What is contract between equals() and hashcode()?
    --------------------------------------------------
        if two objects are same as per equals() method the hashcodes must be same.



                                    Multi Layered Architecture
                                    --------------------------
1) presentation layer (UI)
2) DAO layer (Data Access Objects)
3) service layer

Coupling : dependence
           Loosely Coupled is recommended.
Cohesion : relevance
           Cohesion should be high

UI -> service layer -> dao layer -> Repository (Collection/DB)
UI <- service layer <- dao layer <- Repository (Collection/DB)   


                                    Book Store Management
                                    ---------------------
You should be able to 
    + add a new book to the store
    + delete an unwanted book
    + modify book details
    + retrieve a book
    + rertieve all books

model (beans / pojo)
    contain data
service
    validations on the model
    +
    to call corresponding methods of DAO layer

    
    interface
    implementation classes

dao
    database (collections) related operation

    interface
    implementation classes
ui
    input/output related operations


exceptions are handled in UI layer.
one user defined exception throughout the project.


                                        IOStreams   (java.io)
                                        ---------
                                    (Input Output Streams)  
stream :   flow of data from onpe point to another point.

java.io.File : used to convert the physical file in your file system to a java object.
    methods:
    1) exists()
    2) isFile()
    3) isDirectory()
    4) File[] listFiles()
    5) getName()
    6) length()



IOStreams are divided into 2 categories.
1) text stream      (character steams)
        used to store plain text.

        Reader class
            FileReader
                int read()  : it will read one character at a time.
            BufferedReader
                String readLine() : it will read one line at a time
        Writer class
            FileWriter
            PrintWriter

2) binary stream    (byte stream)
        used to store objects, images, videos and audios.

        InputStream class
            FileInputStream
            ObjectInputStream
                readObject()
        OutputStream class
            FileOutputStream
            ObjectOutputStream
                writeObject()

    Serialization       : storing an object into a file.
    De-Serialization    : retrieving an object from the file.

    To perform Serialization, the class should permit us.
    
    The class whose objects are to be stored in a file, must be inherited from
    java.io.Serializable interface.

    Serializable is a null interface, means is does not contain methods.
    It is also called as Marker Interface.

    transient:
        it is a keyword (modifiers) that indicated the property should NOT be serialized.


    public class Person implements Serializable {
        private String name;
        private String email;
        private transient String ATMPassword;
    }


                                        Multi Threading
                                        ---------------
Multi-Tasking / Multi-Processing:
---------------------------------
1. capability to execute two or more individual processes (task) at a time by an O/S.
2. Every process has it's own heap & stack memory.

Multi-Threading:
----------------
1. In the same application, two related or non-related sub processes run parallely.
2. each sub process is called a thread.
3. All threads will have same heap but different stacks.
   It means data can be exchanged between threads.
4. resources are commonly maintained.

5. Java is by default, Multi-Threaded.


java.lang.Runnable interface
-----------------------------
        public abstract void run()

java.lang.Thread class methods:
----------------------------
0. Thread(Runnable)
1. getName()
2. setName(String)
3. getPriority()    - 1 to 10.  default priority is 5  
            (MIN_PRIORITY, NORM_PRIORITY, MAX_PRIORITY)
4. setPriority(int)
5. start() : will call run() method
6. static sleep(int milliseconds)
7. static currentThread()
8. isAlive()
9. getId()
10. run() : it will contain the task 
11. join() : parent thread will wait until the child thread is finished it's process.
12. setDaemon(boolean)
10. stop(), suspend(), resume(), pause()        : deprecated methods


Daemon Thread:
--------------
Daemon thread is abruptly terminated when no other threads are running.

Synchronization:
----------------
It can be applied on an object or even a code block.
No other thread will disturb when one thread doint it's job.


Thread Life Cycle
----------------------
1) new born state
2) runnable state
3) running state
4) blocked state
5) dead state

                                Thread Pool
                                -----------
A thread pool is a colletion of worker threads.
it minimizes the overhead due to thread creation. Thread objects use a significant amount of 
memory. allocating and deallocating many thread objects creates a memory management overheader.
In this case we can use a Thread Pool. 
Mostly used Thread pool is known as "FixedThreadPool". It is a type of pool always has a specified
number of threads running, tasks are submitted to this pool via an internal queue.

It follow Executable Service Pattern.

java.util.concurrent.ExecutorService
    execute(Runnable)
java.util.concurrent.Executors


                                    Lambda Expressions (JDK 1.8)
                                    ----------------------------

it allows functonality to be passed as an argument to the function.
it is a replacement of Anonymous class that implements a functional interface.
(eg: Comparable, Runnable)

components of lambda expressions:
1) a comma-separated list of formal parameters enclosed in paranthesis
2) we can omit paranthesis if it is a single parameter
3) the arrow token ( -> ) is known as lambda operator
4) a body which consists of a single expression, or statement block.


Interface Arithmetic {
    int add(int a, int b);
    int diff(int a, int b);
}


class ArithmeticImpl implements Arithmetic {
    @Override 
    public int add(int a, int b) {
        return a+b;
    }
    @Override
    public int diff(int a, int b) {
        return a-b;
    }
}

public class Test {
    public static void main(String[] args) {
        ArithmeticImpl obj = new ArithmeticImpl();
        System.out.println(obj.add(10, 5));
        System.out.println(obj.diff(10, 6));
    }
}


using Anonymous class:
----------------------
Interface Arithmetic {
    int add(int a, int b);
    int diff(int a, int b);
}

public class Test {
    public static void main(String[] args) {
        ArithmeticImpl obj = new ArithmeticImpl(new Arithmetic() {
            @Override 
            public int add(int a, int b) {
                return a+b;
            }
            @Override
            public int diff(int a, int b) {
                return a-b;
            }
        })
        System.out.println(obj.add(10, 5));
        System.out.println(obj.diff(10, 6));
    }
}


Day - 11
----------------------------------------------------------------------------------------

SDLC ?
    software development life cycle

    1. requirement gathering
    2. designing (OOAD - class digrams, use case diagrams, sequence diagrams)
    3. coding
    4. testing
    5. deployment  (delivering the final product to client)

software architects
    client satisifaction is important

                    
                    
                                TDD (Test Driven Development)
                                -----------------------------
testing first coding next
coding & testing done parallely

write all possible test cases first
then based on these test cases, one should develop the program.
every test case should be passed. 

testing libraries:
------------------
    JUNIT is a testing framework

    framework = libraries + run time environment

    any library is available in the form of jar file.
    
    junit 4
    junit 5  (as per our syllabus)

    junit 5 uses testing engine "Jupiter"

how do you get these libraries ?
    
    1) download junit related jar files from junit.org
       and place these jar files in a separate folder ("lib" folder)
       add this lib folder to the classpath of the project
    
    (or)
    
    2) eclipse IDE is offering built-in support for junit.

    (or)

    3) we can use build tools like MAVEN, GRADLE etc.,

    Eclipse IDE support maven and gradle tools.
    maven project 
        pom.xml         -   xml format - (dependeny entries)
    
    gradle project      (our )
        build.gradle    -   groovy script - (dependency entries)

    depedencies of library

    central repositories
        maven central Repository- all jar files related to various libraries`

    download necessary jar files related to specified library.


dependencies {
    testImplementation 'org.junit.jupiter  :   junit-jupiter-api   :   5.4.2'
}

testImplementation          =>  scope   (this library is available during unit testing only)
org.junit.jupiter           =>  groupid
junit-jupiter-api           =>  artifactid
5.4.2                       =>  version


setUp methods
tearDown methods


@BeforeEach     :   method under this annotation is executed before each test case is executed
@AfterEach      :   method under this annotation is executed after each test case is executed
@BeforeAll      :   method under this annotation is executed only once before the first 
                    test case is executed.
                    method should be declared as static.
@AfterAll       :   method under this annotation is executed only once after the last 
                    test case is executed.
                    method should be declared as static.

@ParameterizedTest
@CsvSource      : comma-separated value list


@Disabled       : method under this annotation is skipped during unit testing



int subtract(int ... a)
    2 subtracts

    what are various possibities 

        two numbers are equals => result is 0
        if first number is big => result is +ve
        if first number is small => result is -ve
        
test case is nothing but a function, annotated with @Test
@DisplayName("message") => this message is displayed in the test results.


assertion methods:
-------------------
1) assertEquals(expected, actual)
2) assertThrows(expected-type, execute)
3) assertNull(actual)
4) assertTrue()
5) assertFalse()
6) assertArrayEquals(expected, actual, message)
7) assertIterableEquals(expected, actual)
8) assertNotEquals(expected, actual)
9) assertNull(actual)
10) assertSame(expected, actual)
11) assertTimeout(timeout, executable, supplier)
12) fail()

https://junit.org/junit5/docs/5.0.1/api/org/junit/jupiter/api/Assertions.html

Test Suite:     (AllTests.java program)
-----------
collection of test classes.
when you run, all test cases in a specfied package are executed.

@RunWith(JUnitPlatform.class)
@SelectPackages("in.tp.tddd.service")



Day - 12
--------------------------------------------------------------------------------------
                                
                                NIO (New IO)

java.nio package        (jdk 1.7)

Path interface
Paths class
Files class  


                            Built-in functional interfaces
                            ------------------------------

Comparable, Comparator, Runnable

java.util.function package
--------------------------
interface           abstract method
-----------------------------------------------------------------
Consumer<T>         void    accept(T)
Supplier<T>         T       get()
Predicate<T>        boolean test(T)
Function<T,R>       R       apply(T)
UnaryOperator<T>    T       apply(T)
BinaryOperator<T>   T       apply(T,T)


                                    Streams
                                    -------
                                (java.util.Stream)

List<Employee>  employeeList = new ArrayList<>();
employeeList.add(new Employee(....));
...


for(Employee employee : employeeList) {
    if (employee.getSalary() >= 5000) {
        System.out.println(employee);
    }
}

(or)

Stream<Employee>  filteredStream = employeeList.stream()
            .filter(emp -> emp.getSalary() >= 500);
filteredStream.forEach(emp -> System.out.println(emp));


methods:
--------
boolean                         allMatch(Predicate predicate)   
boolean                         anyMatch(Predicate predicate)
long                            count()
Stream<T>                       distinct()
static<T> Stream<T>             empty()
Stream<T>                       filter(Predicate predicate)
Optional<T>                     findAny()
Optional<T>                     findFirst()
void                            forEach(Consumer<T> action)
Stream<T>                       limit(size)
Stream<T>                       skip(size)
Stream                          map(Function )
Option<T>                       max(Comparator )
Option<T>                       min(Comparator )
Stream<T>                       sorted()
Stream<T>                       sorted(Comparator )
Object[]                        toArray()



                                Concurrent Collections
                                -----------------------
                            (java.util.concurrent package)

ConcurrentMap
ConcurrentHashMap
ConcurrentSkipListMap





                                    RDBMS
                    (Relational Database Management System)
                    =======================================

data : collection of facts found in an entity worth remembering.
data processing : operations on data like add, delete, modify,sort, searching 
        data etc.,
information : output of data processing

database : repository of data
database management : adding,deleting,modifying database objects like 
            table, views, indexes etc.,
DBMS : collection of software tools that can manage these database objects 
        efficiently.

DBMS Models:
------------
1) network model
2) hierarchical
3) relational model     (RDBMS)

relation -> collection tuples -> collection of attributes -> attribute contain data
(table  ->  rows    ->      columns     ->      placeholder of data)

RDBMS products:
----------------
1) Postgre SQL      
2) MySQL
3) Oracle
4) DB2
5) MS SQL Server

SQL     (Structured Query Langauge)
-----------------------------------
1. earlier name is sequel
2. it is a common language used to work with any RDBMS product
3. it is a non-procedural language (command based, interactive mode)
4. it is case insensitive
5. each command (statement) must be terminated by semi-colon ( ; )
6. clauses must be written in separate lines for readability (CODING STANDARDS)
7. keywords must be in uppercase and identifiers must be in lowercase.

pgAdmin  :   It is a tool where you can work with Postgre graphically also.
psql     :   command shell of PostGre SQL
postgres :   default database supplied during installation
postgres :   default user name
             password for this user is installation password.

SQL commands - Categories
--------------------------
DDL (Data definition language)      -   CREATE / ALTER / DROP / TRUNCATE 
DML (Data manipulation language)    -   INSERT  / UPDATE / DETELE
DRL (Data retrieval language)       -   SELECT
TCL (Transaction control language)  -   COMMIT / ROLLBACK


psql data types:
----------------
char        : to store fixed length strings
              spaces are added at the end.
varchar     : to store varying length strings.
               
int
float
date        : special values - 'today'
              valid formats - YYYY/MM/DD, DD-MM-YYYY
time        : special values - 'allballs'  - 00:00:00s
timestamp
serial      -   generate auto-incremented values
money


ename       char(30)    

    ravi..........  (4 + 26 spaces) =   30 bytes    
    sudha.........  (5 + 25 spaces) =   30 bytes
    uma...........  (3 + 27 spaces) =   30 bytes

ename       varchar(30)
    ravi                            =   4 bytes
    sudha                           =   5 bytes
    uma                             =   3 bytes


psql offer slash commands (\)

1) \q   :   to come out of psql (shell)
2) \d   :   list of tables, sequences
3) \dt  :   list of tables only
4) \!   :   to execute host operating system commands
            \!  cls
5) \?   :   to list all slash comands

CREATE  TABLE   sales
(itemno     int,
 itemname   varchar(20),
 unitrate   float,
 qty        float
);

structure of the table : column names, data types etc.,

how to see the structure of the table?
--------------------------------------
\dS    tableName



Day - 13
--------------------------------------------------------------
INSERT:
    to add new rows.
syntax:
    INSERT  INTO   tablename [ (column-list)]
    VALUES  (value-list)

date and character literals must be enclosed within single quotes.

INSERT INTO sales
VALUES (101, 'mouse', 300, 2);

INSERT INTO sales
VALUES (102, 'speakers', 650, 1);

INSERT INTO sales (itemno, itemname)
VALUES (103, 'web cam');

INSERT INTO sales (itemno, unitrate, qty)
VALUES (105, 500, 8);


SELECT:
    to retrieve rows.
syntax:
    SELECT  column-list/*
    FROM    tablename;

SELECT *
FROM    sales;


DELETE:
    to delete a row.
syntax:
    DELETE  FROM   tablename
    [WHERE  condition];

DELETE  FROM sales
WHERE itemno = 104;

UPDATE:
    to modify data in an existing row.
syntax:
    UPDATE  tablename
    SET  col-1 = value-1 [, col-2 = value-2, ...]
    [WHERE  condition];

UPDATE   sales
SET  unitrate = 800, qty = 6
WHERE itemno = 103;

UPDATE   sales
SET   itemname = 'micro phone'
WHERE itemno = 105;


TRUNCATE TABLE:
    to delete all rows from the table.
    data cannot be retrieved back.
    but the table remains in the database.
syntax:
    TRUNCATE  TABLE  tablename;

TRUNCATE  TABLE sales;

DROP  TABLE:
    to remove the table permanantly from the database.
syntax:
    DROP   TABLE  tablename;

DROP TABLE sales;


                                        Integrity Constraints
                                        ---------------------
These constraints can be given on a column (or) on combination of columns.
These are verified automatically by the Postgre whenever a row is INSERTed/UPDATEed/DELETEed.
One column can have a single constraint or multiple constraints also.

1) NOT NULL
2) UNIQUE
3) PRIMARY key
4) REFERENCES  (FOREIGN KEY)
5) CHECK (condition)
6) DEFAULT  value

Primary Key:
------------
1. It identify each row uniquely.
2. A Primary is a single column or combination of columns.
3. It should not allow values.
4. It should not allow duplicate values.
5. A table can have ONLY ONE primary key.
5. It create internaly an INDEX on the primary key column. This index is automatically used
   whenever we are performing a search opeation on this column.

Foreign Key:
------------
1. It establishes relation from a child table to a parent table.
2. Foreign key is a single column or combination of columns.
3. It allow null values.
4. it allow duplicate values.
5. A table can have many foreign keys.
6. Every foreign key should be defined as a PRIMARY KEY or UNIQUE KEY in it's parent table.


Constraints can be given in two ways.
1) column-level specification   (along with column definition)
        is used to specify a constraint on a single column
2) table-level specification    (after the last column specification)
        is used to specify a constraint on a single column or on combination of columns.
        we cannot define NOT NULL constraint as table level specification.

every constraint should be given a unique name (CODING STANDARD)
it is generally in the form of tablename_columnname_constraintshortcut (CODING STANDARD)

create a table departments with the following columns.
    deptno (p), dname, location 

CREATE  TABLE  departments
(deptno     int     CONSTRAINT   departments_deptno_pk  PRIMARY KEY,
 dname      varchar(20)  CONSTRAINT departments_dname_nn    NOT NULL,
 location   varchar(20)
);

(or)

CREATE  TABLE  departments
(deptno     int,
 dname      varchar(20)  CONSTRAINT departments_dname_nn    NOT NULL,
 location   varchar(20),
 CONSTRAINT   departments_deptno_pk  PRIMARY   KEY  (deptno)
);


create a table employees with the following columns.
    empno (p), ename (nn), doj (it should not be a future date), salary (min is 5000),
    deptno (f)

CREATE  TABLE  employees
(empno  int  CONSTRAINT  employees_empno_pk  PRIMARY  KEY,
 ename  varchar(20) CONSTRAINT employees_ename_nn  NOT NULL,
 doj    date   CONSTRAINT  employees_doj_chk  CHECK  (doj <= current_date),
 salary float  CONSTRAINT  employees_salary_chk CHECK (salary >= 5000),
 deptno int  CONSTRAINT  employees_deptno_fk  REFERENCES departments(deptno)
);


ALTER TABLE:
------------
    to modify the structure of the table ...
    + add a new column
    + removing a column
    + change the data type of a column
    + change the size of a column
    + add a contraint (using table level specifications)
    + remove a constraint (using table level specifications)
    + rename a column

syntax:
    ALTER  TABLE   tablename
    [ ADD | ALTER | DROP | RENAME ]  (column specification);

CREATE TABLE test
(empno int,
 ename varchar(5)
);

ALTER TABLE test
ADD COLUMN salary  float;

How to add multiple columns at a time?
ALTER TABLE test
ADD COLUMN c1 int, ADD COLUMN c2 int;

ALTER TABLE test
ALTER COLUMN ename TYPE varchar(6);

ALTER TABLE test
DROP COLUMN c1;

How to remove multiple columns at once?
...

ALTER TABLE test
ADD CONSTRAINT test_empno_pk PRIMARY KEY(empno);

ALTER TABLE test
DROP CONSTRAINT test_empno_pk;

ALTER TABLE test
ADD CONSTRAINT test_salary_chk CHECK (salary >= 10000);

ALTER TABLE test
DROP CONSTRAINT test_salary_chk;

ALTER TABLE test
RENAME COLUMN salary TO sal;


SELECT:
-------
SELECT 2*3+4;

SELECT 5/10;

bonus is 10% of the salary.

SELECT empno, ename, doj, salary, deptno, salary*10/100
FROM  employees;

monthly salary of all employees?
(salary + allowance)

SELECT empno, ename, salary, allowance, salary+allowance as "Monthly Salary"
FROM employees;

"Montly Salary" is called as column alias.

concatenated columns:
---------------------
two or more columns can be concatenated by using concatenation operator ( || ).

SELECT  empno, first_name || ' ' || last_name 
FROM    employees;

column aliases:
---------------
It is a new name given for a column used in the output of select statement.
It is generally used for derived or computational columns.

SELECT  empno, first_name || ' ' || last_name AS "Full Name"
FROM    employees;


NULL:
-----
    when a column lacks value, then it is said to be NULL.
    a NULL is not same as 0.
    it is either unavailable, unpredicted or undetermined.
    any arithmetic operation performed with NULL value leads to NULL result.

NULLIF(value-1, value-2)
    it replace value-1 in the expression if value-2 is null.

SELECT empno, ename, salary, allowance, NULLIF(0, salary)+allowance as "Monthly Salary"
FROM employees; 


DISTINCT:
    to elimnate duplicate rows in the output.

SELECT DISTINCT deptno
FROM employees;

SELECT DISTINCT deptno, salary
FROM employees;

WHERE:
------
    to display rows that satisify given condition.

SELECT  empno, ename, salary, deptno
FROM employees
WHERE  deptno = 10;

SELECT empno, ename
FROM employees
WHERe ename = 'ramu';       (comparision is always case sensitive)

SELECT empno, ename, doj
FROM employees
WHERE doj >= '01-01-2000';

AND, OR, NOT        (logical operators)

SELECT  empno, ename, salary, deptno
FROM employees
WHERE  deptno = 10 
AND salary >= 5000;

SELECT  empno, ename, salary, deptno
FROM employees
WHERE  deptno = 10 
OR salary >= 5000;

SELECT  empno, ename, salary, deptno
FROM employees
WHERE  NOT deptno = 10;

(or)

SELECT  empno, ename, salary, deptno
FROM employees
WHERE  deptno != 10;

SQL Operators:
1) IN   (value-1, value-2, ...)
2) BETWEEN  value-1 AND value-2
        value-1  <= value-2

3) LIKE     'character-pattern'
        wild card searching
        %   replace 0 or more unknown characters
        _   replace 0 or 1 unknown characters
4) ILIKE
    performs case insensitive search

5) IS NULL

Negation Opertors:
------------------
1) NOT IN   (value-1, value-2, ...)
2) NOT BETWEEN  value-1 AND value-2
3) NOT LIKE     'character-pattern'
4) NOT ILIKE     'character-pattern'
5) IS NOT NULL


SELECT  empno, ename, salary, deptno
FROM employees
WHERE  salary BETWEEN 2000 AND 7000;

(or)

SELECT  empno, ename, salary, deptno
FROM employees
WHERE  salary >= 2000 AND salary <= 7000;


SELECT  empno, ename, salary, deptno
FROM employees
WHERE  deptno IN (10,30,20);

(or)

SELECT  empno, ename, salary, deptno
FROM employees
WHERE  deptno  = 10  OR  deptno = 30  OR  deptno = 20;

SELECT empno, ename
FROM employees
WHERE ename LIKE 'r%';

SELECT empno, ename
FROM employees
WHERE ename LIKE '%r';

SELECT empno, ename
FROM employees
WHERE ename LIKE '%r%';

display all employees whose name contain second character as 'a'.

SELECT empno, ename
FROM employees
WHERE ename LIKE '_a%';

display all employees who do not belong to any department.

SELECT empno, ename, deptno
FROM employees
WHERE deptno IS NULL;

ORDER BY:
----------
The order of retrieval of rows from the select command is uncertain.
to control the order of retreival, we can use ORDER BY clause.
if used, ORDER BY must be the last clause in statement.

SELECT empno, ename, salary
FROM employees
ORDER BY salary;

SELECT empno, ename, salary
FROM employees
ORDER BY salary desc NULLS LAST;

SELECT empno, ename, salary, deptno
FROM employees
ORDER BY deptno, ename DESC;

SELECT empno, ename, salary, deptno
FROM employees
WHERE salary >= 5000
ORDER BY deptno;

library functions
-----------------
1) power(b,e)
2) abs(n)
3) sqrt(n)
4) sin(n)
5) pi()
6) round(n)
7) trunc(number, decimal_places)
8) ceil(n)
9) floor(n)


10) upper(s)
11) lower(s)
12 initcap(s)
13) length(s)

14) sum(col)
15) avg(col)
16) min(col)
17) max(col)
18) count(col)

19) now()
20) extract()
21) age(latest_date, earliest_date)


SELECT sum(salary), avg(salary), min(salary), max(salary)
FROM employees;

SELECT count(salary)
FROM employees;

SELECT count(*)
FROM employees;

SELECT NOW();
return current date and time

SELECT NOW()::DATE;
return current date only

SELECT NOW()::TIME
return current time only

SELECT NOW() - INTERVAL '1 YEAR';
substract 1 year from current date.
 
SELECT NOW() - INTERVAL '10 YEARS';

SELECT NOW() - INTERVAL '10 MONTHS';

SELECT NOW() - INTERVAL '10 DAY';

SELECT NOW() + INTERVAL '10 DAYS';

SELECT NOW() + INTERVAL '10 MONTHS';

SELECT NOW()::DATE + INTERVAL '10 MONTHS';

SELECT (NOW()::DATE + INTERVAL '10 MONTHS')::DATE;
truncate the time portion from the result.

SELECT EXTRACT(YEAR FROM NOW());

SELECT EXTRACT(MONTH FROM NOW());

SELECT EXTRACT(DAY FROM NOW());

SELECT EXTRACT(CENTURY FROM NOW());

SELECT first_name, last_name, gender, country_of_birth, date_of_birth, 
AGE(NOW(), date_of_birth) AS age
FROM persons;


GROUP BY:
---------
used to divide rows into groups, and we can perform any aggregate operations on each group.

SELECT deptno, SUM(salary)
FROM employees
GROUP BY deptno;

SELECT deptno, SUM(salary)
FROM employees
GROUP BY deptno
ORDER BY SUM(salary) DESC;


Note:
-----
The column that is not surrounded by any aggregate function in the select column list
must be included in the group by clause.


Day - 14
-----------------------------------------------------------------------------

HAVING clause:
--------------
    this is used to filter rows after grouping.

SELECT deptno, SUM(salary)
FROM employees
GROUP BY deptno
HAVING SUM(salary) > 10000;

SELECT deptno, SUM(salary)
FROM employees
WHERE deptno > 50
GROUP BY deptno
HAVING SUM(salary) > 10000;

What is the difference between WHERE and HAVING ?
-------------------------------------------------
WHERE clause is used to filter rows before grouping.
HAVING clause is used to filter rows after grouping.

WHERE clause do not permit to use aggregate functions.
HAVING clause support aggregate functions.

WHERE clause is no way related to GROUPing.
HAVING clause should always be used along with GROUP BY clause.


                                LIMIT, OFFSET, FETCH
                                --------------------

LIMIT is not a standard SQL clause.

to return top 3 earners.
SELECT empno, ename, salary
FROM employees
ORDER BY salary DESC NULLS LAST
LIMIT 3;


to return all rows start from 6 to 15.
SELECT *
FROM persons
OFFSET 5 LIMIT 10;

to return all rows start from row 20 till the last row.
SELECT *
FROM persons
OFFSET 20;

instead of LIMIT clause, we can use FETCH.  (it is an SQL standard)
------------------------------------------
FETCH FIRST

to display from row 6 to 15.
SELECT *
FROM persons
OFFSET 5 FETCH FIRST 10 ROW ONLY;



creating database:
------------------
syntax:
    CREATE  DATABASE   databaseName;

CREATE DATABASE emdb;


to list all databases:
----------------------
\l

how to connect to a particular database?
----------------------------------------
\c databaseName;

\c emdb;

deleting database:
------------------
syntax:
    DROP  DATABASE  databaseName;

DROP  DATABASE emdb;

SEQUENCE:
---------
It is also database object (like table, view, index).
It is used to generate series and these values can be used to supply data into field
during insert command.

SERIAL datatype:
----------------
It is a data type of PSQL. (int type)
When a column is assigned serial type, internally a sequence is created.
using the sequence, values are generated and they are inserted into the column whose datatype
is serial.
the sequqnce name is automatically takes as "tablename_columnname_seq"
(eg: t1_empno_seq)


                                        JOIN
                                        ----

It is used to retrieve data from multiple related tables.
They should have common column.

display empno, ename, salary, dname of all employees.

SELECT  E.empno, E.ename, E.salary, D.dname, E.deptno
FROM    employees E, departments D;
WHERE   E.deptno = D.deptno;

condition given in WHERE clause is known as "Join Condition".

There are 2 types.
1) equi-join
    if the join condition is given based on equality
2) non-equi join
    if the join condition is given on any other operator except equality


inner join
    display all matching rows
outer join
    display all matching and non-matching rows.

    LEFT OUTER JOIN         : all matching rows AND missing rows from LEFT table
    RIGHT OUTER JOIN        : all matching rows AND missing rows from RIGHT table
    FULL OUTER JOIN         : all matching rows AND missing rows from both the tables.

SELECT  E.empno, E.ename, E.salary, D.dname, E.deptno
FROM    employees E
JOIN    departments D
ON   E.deptno = D.deptno;

SELECT  E.empno, E.ename, E.salary, D.dname, D.deptno
FROM    employees E
RIGHT  OUTER JOIN    departments D
ON   E.deptno = D.deptno;

SELECT  E.empno, E.ename, E.salary, D.dname, D.deptno
FROM    employees E
FULL  OUTER JOIN    departments D
ON   E.deptno = D.deptno;


Rule:
-----
Minimum number of join conditions = no. of tables to be joined - 1

SELECT  empno, ename, dname, country
FROM employees E
JOIN departments D 
ON E.deptno = D.deptno
JOIN countries C
ON D.loc = C.loc;

Note:
-----
if the join condition is invalid, or completely eliminated the result is known as
CARTESIAN PRODUCT.

SELECT  E.empno, E.ename, E.salary, D.dname, E.deptno
FROM    employees E, departments D;


                                    SET OPERATORS
                                    -------------
UNION
INTERSECT
EXCEPT

set operators are used to get the results out of two queries.

SELECT DISTINCT deptno FROM employees
UNION
SELECT deptno FROM departments;


SELECT DISTINCT deptno FROM employees
INTERSECT
SELECT deptno FROM departments;

SELECT DISTINCT deptno FROM employees
EXCEPT
SELECT deptno FROM departments;

SELECT deptno FROM departments
EXCEPT
SELECT DISTINCT deptno FROM employees;


                                SUB QUERY
                                ---------
sub query is also called as  "inner query" or "sub select".
the sub query is exceuted first, then the result is passed to "main query" or "outer query".
with this result, main query is executed.

display the ename, salary, dname who is earning highest salary.


SELECT E.ename, E.salary, D.dname
FROM employees E, departments D
WHERE E.deptno = D.deptno
AND E.salary = (SELECT MAX(salary) FROM employees);

(or)


SELECT E.ename, E.salary, D.dname
FROM employees E
JOIN departments D
ON E.deptno = D.deptno
WHERE E.salary = (SELECT MAX(salary) FROM employees);


                                    Correlated SubQuery
                                    -------------------
Takes one row from the main query.
use this row to qualify the sub query.
Correlated subquery is executed as many rows as the main query contain.

if the condition of subquery contain a column of the main query then it is identified as
correlated sub query.

Display all employees whose salary is more than the average salary of their department.

101     ramu        5000        10
102     kumar       6000        10
103     ramana      7000        10
104     devi        4000        10

SELECT empno, ename, salary, deptno
FROM employees E
WHERE salary < (SELECT avg(salary)
                FROM    employees
                WHERE deptno = E.deptno);


                                VIEWS
                                -----
It is a virtual table.
It is like a window.
It does not contain any data on it's own.
It is stored as select statement only.

Insert, Update and Delete operation on simple view, affects the base table only.
DML Operations are NOT POSSIBLE on complex view.

There are 2 Types.
1) simple view
    if the view is created on a single table
    if the view doesnot contain GROUP BY

2) complex view
    if the view is created on multiple tables
    if the view contain GROUP BY clause.

CREATE  VIEW   viewName
AS
SELECT statement;

CREATE  VIEW    costly_employees
AS
SELECT * 
FROM employees
WHERE salary > 8000;

SELECT *
FROM costly_employees;

DROP VIEW costly_employees;




CREATE VIEW employee_full_details
AS
SELECT empno, ename, salary, dname
FROM employees E
JOIN departments D
ON E.deptno = D.deptno;


SELECT * 
FROM employee_full_details;

To list all views:
------------------
\dv




                                        INDEX
                                        -----
It is meant for faster searching.
For all primary keys, unique keys an index is generated automatically.
Querying on index columns help to retrive data in much faster way.


50,00,000 rows in a table.
bank statement (last 3 months)

transactionId   (p)
accountnumber               index for it
trandate                    index for it


SELECT *
FROM transactions
WHERE accountnumber = 10123400
AND trandate BETWEEN now() and now() - interval '3 months';

we have to create index on accountnumber + trandate
so that searching become faster.

CREATE  INDEX  employees_doj_index
ON  employees(doj);

DROP  INDEX  employees_doj_index;

To list all indexes:
---------------------
\di

gradle dependency:
------------------------
implementation group: 'org.postgresql', name: 'postgresql', version: '42.2.15'


                                            JDBC
                                (Java Data Base Connectivity)
                                -----------------------------
                                        (java.sql)

JDBC API:       
---------
    API contain collection of interfaces, abstract classes.
    It is all about specifications.

JDBC Implementations:
---------------------
    offered by database vendors.
    Oracle Implementation for JDBC
    MySQL Implementation for JDBC
    Postgre SQL Implementation for JDBC

JDBC Drivers
------------
    collection of jar file(s) that contain implementation classes for JDBC API.

    It should be available to your project if we want to integrate our java program with
    postgre sql. so that we can store data of java program to postgre database. similarly
    we can get data from postgre into java program.

    1) download postgre jdbc driver from internet, put the driver in a special folder
       "lib" folder, and make this lib folder available to classpath.

    (or)

    2) create a gradle project, add the postgre dependency in build.gradle then the jdbc driver
       related jar(s) are automatically downloaded from internet.

Types of JDBC Drivers:
----------------------
we will use Type-4 Driver also known as "Thin Driver".


steps to write jdbc program:
-----------------------------
1. load the jdbc driver class   (Java 8 - This step is optional)
2. connect to database and open the connection
3. create a statement object
4. execute statement
5. close the connection


Connection interface
    getMetaData()
DriverManager class
    getConnection(String url, String userName, String password)
DatabaseMetaData class
    getDatabaseProductName()
    getDatabaseProductVersion()










                                
